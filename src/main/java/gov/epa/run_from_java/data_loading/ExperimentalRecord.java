package gov.epa.run_from_java.data_loading;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.List;

import jakarta.persistence.Transient;

import org.apache.commons.text.StringEscapeUtils;

import com.google.gson.JsonObject;

import gov.epa.databases.dev_qsar.exp_prop.entity.LiteratureSource;
import gov.epa.databases.dev_qsar.exp_prop.entity.ParameterValue;
import gov.epa.databases.dev_qsar.exp_prop.entity.PublicSource;
import gov.epa.databases.dev_qsar.exp_prop.entity.SourceChemical;

import gov.epa.run_from_java.scripts.GetExpPropInfo.Utilities;


public class ExperimentalRecord {

	//******************************************************************************************************
	//Source chemical fields:
	public String id_physchem;//Autonumbered record number for physchem data (now generated by database)
//	public String id_record_source;//Record number for reference that the physchem data came from (generated by database later- may only need for records from journal articles)
//	public Long id_source_database; //main id number from the database it came from such as toxval_id- TODO should we store in experimental_parameters instead?
	public String comboID;//
	public String einecs;
	public String dsstox_compound_id; //DSSTox substance identifier
	
	public String casrn; // Source chemical CAS (Chemical Abstracts Service) number
	public String chemical_name; // Source chemical name
	public String synonyms; // Source chemical synonyms
	public String smiles; // Source chemical SMILES (Simplified Molecular-Input Line-Entry System)
	public String dsstox_substance_id; // Source chemical DSSTox substance identifier
	//******************************************************************************************************
	//Property value fields:
	public String property_name;//	Name of the property (use  "options_property_names" lookup table to consistently populate the field)
	public String property_category;//keep?
	public String property_value_string;//Store original string from source for checking later
	public String property_value_string_parsed;
	
	public Double property_value_min_original;//The minimum value of a property when a range of values is given
	public Double property_value_max_original;//The maximum value of a property when a range of values is given
	public Double property_value_point_estimate_original;// Point estimate of the property (when a single value is given)
	public String property_value_units_original;//The units for the property value (convert to defined values in ExperimentalConstants class)

	//Converted property value fields:
	public String property_value_numeric_qualifier;// >, <, or ~
	public Double property_value_min_final;//The minimum value of a property when a range of values is given
	public Double property_value_max_final;//The maximum value of a property when a range of values is given
	public Double property_value_point_estimate_final;// Point estimate of the property (when a single value is given)
	public String property_value_units_final;//The units for the property value (convert to defined values in ExperimentalConstants class)
	public String property_value_qualitative;// Valid qualitative data: solubility descriptor, appearance
	
	//Experimental parameters:
	public Double temperature_C;//The temperature in C that the property is measured at (vapor pressure might be given at 23 C for example)
	public String pressure_mmHg;//The pressure in kPa that the property is measured at (important for boiling points for example)
	public String pH;
	public String measurement_method;//	The experimental method used to measure the property
	public String reliability;
	public Hashtable <String,Object> experimental_parameters=null;//TODO should we store above conditions in this hashtable directly?

	//Make transient because wont write ExperimentalRecords due to objects referencing each other in infinite loop
	public List <ParameterValue> parameter_values;//If have numerical values with units store parameters as list of ParameterValues
	
	public String note;//	Any additional note

	//Source metadata:
	public String url;
	
	public PublicSource publicSource;//TODO need to eventually store as object instead of just has source_name
	public String source_name;//use Experimental constants

	public String original_source_name;//If specific reference/paper provided ==> when loading it creates an entry for original public_source
	public PublicSource publicSourceOriginal;
	
	public String document_name;
	public String file_name;

	public String reference;//keep? used for easier displaying lit source in checking spreadsheet
	public LiteratureSource literatureSource;

	//"original_source_name" rather than "source_name_original" to avoid syntactic confusion with "*_original" vs "*_final" fields above
	public String fr_id;
	public String date_accessed;//use Experimental constants
	
	public boolean keep=true;//Does the record contain useful data? keep might be different depending on whether goal is for database or for QSAR data set
	public boolean flag=false;
	public String reason;//If keep=false or flag=true, why?
	
	
	//Converting to ArrayList allows you to add to it later...
		public final static List<String> outputFieldNames= new ArrayList<String>(Arrays.asList("id_physchem",
				"keep",			
				"reason",
				"casrn",
				"dsstox_substance_id",
				"einecs",
				"chemical_name",
				"synonyms",
				"smiles",
				"source_name",
				"property_name",
				"property_value_point_estimate_original",
				"property_value_min_original",
				"property_value_max_original",
				"property_value_units_original",
				"property_value_string",
				"property_value_string_parsed",
				"property_value_qualitative",
				"property_value_numeric_qualifier",
				"property_value_point_estimate_final",
				"property_value_min_final",
				"property_value_max_final",
				"property_value_units_final",
				"pressure_mmHg",
				"temperature_C",
				"pH",
				"measurement_method",
				"note",
				"flag",
				"original_source_name",
				"document_name",
				"file_name",
				"reference",
				"url",
				"date_accessed"));
	
	public SourceChemical getSourceChemical(String lanId,PublicSource publicSource,LiteratureSource literatureSource) {
		SourceChemical sourceChemical = new SourceChemical();
		sourceChemical.setCreatedBy(lanId);

		if (casrn!=null && !casrn.isBlank()) {
			sourceChemical.setSourceCasrn(casrn);
		}

		if (chemical_name!=null && !chemical_name.isBlank()) {
			sourceChemical.setSourceChemicalName(chemical_name);
		}

		if (smiles!=null && !smiles.isBlank()) {
			sourceChemical.setSourceSmiles(smiles);
		}

		if (dsstox_substance_id!=null && !dsstox_substance_id.isBlank()) {
			if (dsstox_substance_id.startsWith("DTXCID")) {
				sourceChemical.setSourceDtxcid(dsstox_substance_id);
			} else if (dsstox_substance_id.startsWith("DTXSID")) {
				sourceChemical.setSourceDtxsid(dsstox_substance_id);
			} else if (dsstox_substance_id.startsWith("DTXRID")) {
				sourceChemical.setSourceDtxrid(dsstox_substance_id);
			}
		}
		
		sourceChemical.setLiteratureSource(literatureSource);
		sourceChemical.setPublicSource(publicSource);
		return sourceChemical;

	}
	
	public static String fixCASLeadingZero(String cas) {
		if (cas!=null && !cas.isBlank()) {
			cas=cas.trim();
			while (cas.substring(0,1).contentEquals("0")) {//trim off zeros at front
				cas=cas.substring(1,cas.length());
			}
			return cas;
		} else {
			return null;
		}
	}
	
	public void setComboID(String del) {
		String CAS=casrn;
		
		if (CAS==null || CAS.trim().isEmpty()) CAS="casrn=null";//need placeholder so dont get spurious match in chemreg
		else {
			CAS=fixCASLeadingZero(CAS);
		}
		String name=StringEscapeUtils.escapeJava(chemical_name);
		
		String EINECS=einecs;
		if (EINECS==null || EINECS.trim().isEmpty()) EINECS="einecs=null";//need placeholder so dont get spurious match in chemreg
		EINECS=EINECS.trim();
		
		if (name==null || name.trim().isEmpty()) name="name=null";//need placeholder so dont get spurious match in chemreg
		name=name.trim();
		
		String SMILES=smiles;
		if (SMILES==null || SMILES.trim().isEmpty()) SMILES="smiles=null";//need placeholder so dont get spurious match in chemreg
		SMILES=SMILES.trim();
				
		String DTXSID=dsstox_substance_id;
		if(DTXSID==null) DTXSID="dtxsid=null";

		String DTXCID=dsstox_compound_id;
		if(DTXCID==null) DTXCID="dtxcid=null";

		//TODO omit chemicals where smiles indicates bad element....
		
		comboID=CAS+del+EINECS+del+name+del+SMILES+del+DTXSID+del+DTXCID;
		
	}
	
	
	
	public String toString() {
		return toString("|");
	}
	public String toString(String del) {
		// TODO Auto-generated method stub
		return toString(del,outputFieldNames);
	}
	
	//convert to string by reflection:
	public String toString(String del,List<String> fieldNames) {

		String Line = "";
		
		for (int i = 0; i < fieldNames.size(); i++) {
			try {


				Field myField = this.getClass().getDeclaredField(fieldNames.get(i));

				String val=null;

//				System.out.println(fieldNames[i]+"\t"+myField.getType().getName());

				if (myField.getType().getName().contains("Double")) {
					if (myField.get(this)==null) {
						val="";	
					} else {
						val=myField.get(this)+"";
					}

				} else if (myField.getType().getName().contains("Integer")) {
					if (myField.get(this)==null) {
						val="";	
					} else {
						val=myField.get(this)+"";
					}
				} else if (myField.getType().getName().contains("Boolean")) {
					if (myField.get(this)==null) {
						val="";	
					} else {
						val=myField.get(this)+"";
					}
					
				} else if (myField.getType().getName().contains("boolean")) {
					val=myField.getBoolean(this)+"";
				
				
				} else {//string
					if (myField.get(this)==null) {
						//								val="\"\"";
						val="";
					} else {
						//								val="\""+(String)myField.get(this)+"\"";
						val=(String)myField.get(this);
					} 
				}

				val=val.replace("\r\n","<br>");
				val=val.replace("\n","<br>");

				if (val.contains(del)) {
					val=val.replace(del,"_");
//					System.out.println("***WARNING***"+this.casrn+"\t"+val+"\thas delimiter in field "+fieldNames.get(i)+" del="+del);
				}

				Line += val;
				if (i < fieldNames.size() - 1) {
					Line += del;
				}


			} catch (Exception e) {
				e.printStackTrace();
			}

		}

		return Line;
	}
	
	public String toJson(List<String> fieldNames) {

		
		JsonObject jo=new JsonObject();
		
		for (int i = 0; i < fieldNames.size(); i++) {
			try {

				Field myField = this.getClass().getDeclaredField(fieldNames.get(i));

				String val=null;

//				System.out.println(fieldNames[i]+"\t"+myField.getType().getName());

				if (myField.getType().getName().contains("Double")) {
					if (myField.get(this)==null) {
						continue;	
					} else {
						val=myField.get(this)+"";
					}

				} else if (myField.getType().getName().contains("Integer")) {
					if (myField.get(this)==null) {
						continue;		
					} else {
						val=myField.get(this)+"";
					}
				} else if (myField.getType().getName().contains("Boolean")) {
					if (myField.get(this)==null) {
						continue;		
					} else {
						val=myField.get(this)+"";
					}
					
				} else if (myField.getType().getName().contains("boolean")) {
					val=myField.getBoolean(this)+"";
				} else {//string
					if (myField.get(this)==null) {
						continue;	
					} else {
						//								val="\""+(String)myField.get(this)+"\"";
						val=(String)myField.get(this);
					} 
				}

				val=val.replace("\r\n","<br>");
				val=val.replace("\n","<br>");

				jo.addProperty(fieldNames.get(i), val);
				

			} catch (Exception e) {
				e.printStackTrace();
			}

		}

		return Utilities.gson.toJson(jo);
	}
}
